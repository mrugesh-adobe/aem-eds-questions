{
  "easy": [
    {
      "id": "e1",
      "title": "What is AEM Edge Delivery Services (EDS)?",
      "answer": "<p>Adobe Experience Manager Edge Delivery Services (AEM EDS) is a modern web delivery platform that enables developers to build and deploy fast, content-centric websites at scale.</p><p>Key features of AEM EDS include:</p><ul><li>Block-based architecture for modular content creation</li><li>Edge delivery for optimal performance worldwide</li><li>Git-based workflows for developer efficiency</li><li>Content-first approach with Markdown authoring</li><li>Universal Editor for WYSIWYG content editing</li><li>Built-in performance optimization</li></ul><p>Unlike traditional AEM, EDS focuses on delivering content through a CDN edge network, resulting in faster page loads and better user experiences.</p>",
      "code": "// Example of importing an EDS block\nimport { createOptimizedPicture } from '../../scripts/lib-franklin.js';\n\n// Block function that processes content\nexport default function decorate(block) {\n  // Transform block content\n  const picture = createOptimizedPicture(block.querySelector('img').src);\n  block.innerHTML = '';\n  block.append(picture);\n}"
    },
    {
      "id": "e2",
      "title": "How does EDS differ from traditional AEM?",
      "answer": "<p>AEM Edge Delivery Services represents a significant shift from traditional AEM in several key ways:</p><table><tr><th>Traditional AEM</th><th>AEM Edge Delivery Services</th></tr><tr><td>Server-side rendering with Java/JSP/HTL</td><td>Static site generation with edge-side processing</td></tr><tr><td>Component-based architecture</td><td>Block-based architecture</td></tr><tr><td>Complex authoring interface</td><td>Simplified content-first approach with Markdown</td></tr><tr><td>JCR repository for content</td><td>Git-based content management</td></tr><tr><td>Developer workflow through package manager</td><td>Modern CI/CD pipelines with GitHub integration</td></tr><tr><td>Complex deployment process</td><td>Automated deployment through Helix pipeline</td></tr></table><p>EDS prioritizes performance, simplicity, and developer experience while maintaining the content management capabilities that AEM is known for.</p>"
    },
    {
      "id": "e3",
      "title": "What are Blocks in AEM EDS?",
      "answer": "<p>Blocks are the fundamental building units in AEM Edge Delivery Services. They are modular, reusable components that make up the content of a webpage.</p><p>Key characteristics of EDS Blocks:</p><ul><li><strong>Structure:</strong> Each block is defined by HTML markup in a document section with a specific class name</li><li><strong>Styling:</strong> Blocks have their own CSS files for styling</li><li><strong>Behavior:</strong> JavaScript files provide interactive functionality</li><li><strong>Modularity:</strong> Blocks can be reused across multiple pages</li><li><strong>Variants:</strong> Blocks can have multiple variations with different styling or behavior</li></ul><p>Blocks are automatically loaded by the EDS runtime when they appear on a page, making the development process more efficient and maintainable.</p>",
      "code": "// Example block.js file\nexport default function decorate(block) {\n  // Get all rows in the block\n  const rows = [...block.children];\n  \n  // Process each row\n  rows.forEach((row) => {\n    // Get cells in the row\n    const cells = [...row.children];\n    \n    // Add classes for styling\n    row.classList.add('my-block-row');\n    cells.forEach((cell) => {\n      cell.classList.add('my-block-cell');\n    });\n  });\n}"
    }
  ],
  "medium": [
    {
      "id": "m1",
      "title": "Explain the EDS Block Architecture",
      "answer": "<p>The AEM EDS Block Architecture is a modular approach to building websites that separates content, presentation, and behavior into distinct units called blocks.</p><h3>Block Structure</h3><p>Each block consists of three main files:</p><ol><li><strong>block.js</strong>: Contains the JavaScript logic for transforming the block's content</li><li><strong>block.css</strong>: Contains the styling specific to the block</li><li><strong>block.js.map and block.css.map</strong>: Source maps for debugging</li></ol><h3>Block Loading Process</h3><p>When a page loads in EDS:</p><ol><li>The page HTML is loaded with block placeholders</li><li>The EDS runtime identifies blocks in the page</li><li>For each block, the corresponding JS and CSS are loaded</li><li>The block's decorate function transforms the content</li><li>The block is rendered on the page</li></ol><p>This architecture enables efficient loading, as only the resources needed for blocks on the current page are loaded.</p>",
      "code": "// Block loading process (simplified)\nexport async function loadBlocks() {\n  // Find all blocks on the page\n  const blocks = document.querySelectorAll('div.block');\n  \n  // Process each block\n  await Promise.all([...blocks].map(async (block) => {\n    const blockName = block.classList[1];\n    \n    // Load block CSS\n    await loadCSS(`/blocks/${blockName}/${blockName}.css`);\n    \n    // Load block JS\n    try {\n      const mod = await import(`/blocks/${blockName}/${blockName}.js`);\n      if (mod.default) {\n        await mod.default(block);\n      }\n    } catch (err) {\n      // Handle error\n      console.error(`Error loading block ${blockName}:`, err);\n    }\n  }));\n}"
    },
    {
      "id": "m2",
      "title": "How do EdgeWorkers function in AEM EDS?",
      "answer": "<p>EdgeWorkers are a key component of AEM Edge Delivery Services that enable dynamic functionality at the CDN edge, closer to the user.</p><h3>EdgeWorker Capabilities</h3><ul><li>Server-side processing without traditional backend servers</li><li>Dynamic content generation based on user context</li><li>API integrations at the edge</li><li>Personalization based on user data</li><li>A/B testing implementation</li><li>Authentication and authorization</li></ul><h3>EdgeWorker Implementation</h3><p>EdgeWorkers are JavaScript functions that run on Akamai's edge network. They intercept requests before they reach the origin server and can modify responses before they're delivered to the user.</p><p>In EDS, EdgeWorkers are typically used for:</p><ul><li>Implementing personalization logic</li><li>Processing form submissions</li><li>Integrating with external APIs</li><li>Implementing authentication flows</li><li>Optimizing content delivery based on device or location</li></ul>",
      "code": "// Example EdgeWorker for personalization\nexport async function onClientRequest(request) {\n  // Get user location from request\n  const userLocation = request.userLocation.country;\n  \n  // Set header for use in content delivery\n  request.setHeader('X-User-Location', userLocation);\n  \n  // Continue processing the request\n  return request;\n}\n\nexport async function onClientResponse(request, response) {\n  // Get user location from request header\n  const userLocation = request.getHeader('X-User-Location');\n  \n  // Modify response based on location\n  if (userLocation === 'US') {\n    // Modify content for US users\n    response.body = response.body\n      .replace('{{region}}', 'United States')\n      .replace('{{currency}}', 'USD');\n  } else if (userLocation === 'UK') {\n    // Modify content for UK users\n    response.body = response.body\n      .replace('{{region}}', 'United Kingdom')\n      .replace('{{currency}}', 'GBP');\n  }\n  \n  return response;\n}"
    },
    {
      "id": "m3",
      "title": "Describe the EDS Publishing Process",
      "answer": "<p>The AEM Edge Delivery Services publishing process follows a modern, Git-based workflow that automates content delivery from authoring to production.</p><h3>Publishing Workflow</h3><ol><li><strong>Content Authoring</strong>: Authors create or edit content using Markdown in the AEM Universal Editor or directly in Git</li><li><strong>Content Commit</strong>: Changes are committed to a Git repository (typically GitHub)</li><li><strong>CI/CD Pipeline</strong>: The commit triggers the Helix Pipeline</li><li><strong>Build Process</strong>: The pipeline builds the site, processing Markdown to HTML and optimizing assets</li><li><strong>Preview Deployment</strong>: Changes are deployed to a preview environment</li><li><strong>Content Review</strong>: Authors review content in the preview environment</li><li><strong>Production Deployment</strong>: Approved changes are merged to the main branch and deployed to production</li><li><strong>CDN Distribution</strong>: Content is distributed to edge nodes worldwide</li></ol><h3>Key Benefits</h3><ul><li>Version control for all content changes</li><li>Automated testing and validation</li><li>Preview environments for each change</li><li>Rollback capability for any deployment</li><li>Separation of code and content workflows</li></ul>"
    }
  ],
  "hard": [
    {
      "id": "h1",
      "title": "Implementing Advanced Block Variations in EDS",
      "answer": "<p>Implementing advanced block variations in AEM Edge Delivery Services requires a deep understanding of the block architecture and how to leverage it for complex use cases.</p><h3>Block Variation Strategies</h3><ol><li><strong>CSS-based Variations</strong>: Using additional CSS classes to modify block appearance</li><li><strong>Section-based Variations</strong>: Using section metadata to control block behavior</li><li><strong>Content Structure Variations</strong>: Detecting patterns in the content structure to apply different layouts</li><li><strong>Dynamic Variations</strong>: Using JavaScript to modify block behavior based on runtime conditions</li></ol><h3>Implementation Approach</h3><p>To implement advanced block variations:</p><ol><li>Create a base block implementation that handles common functionality</li><li>Detect variation indicators (classes, metadata, content structure)</li><li>Apply conditional logic in the block's decorate function</li><li>Use CSS to style different variations</li><li>Document the variation options for content authors</li></ol><p>This approach allows for a single block implementation to handle multiple presentation and behavior patterns while maintaining a clean content authoring experience.</p>",
      "code": "// Advanced block variation implementation\nexport default function decorate(block) {\n  // Get block variation from section metadata or block classes\n  const sectionMetadata = block.closest('.section').dataset;\n  const blockClasses = [...block.classList];\n  \n  // Determine variation type\n  let variation = 'default';\n  \n  if (blockClasses.includes('highlight')) {\n    variation = 'highlight';\n  } else if (blockClasses.includes('compact')) {\n    variation = 'compact';\n  } else if (sectionMetadata.style === 'dark') {\n    variation = 'dark';\n  }\n  \n  // Add variation class to block\n  block.classList.add(`${block.classList[1]}-${variation}`);\n  \n  // Apply variation-specific transformations\n  switch (variation) {\n    case 'highlight':\n      applyHighlightVariation(block);\n      break;\n    case 'compact':\n      applyCompactVariation(block);\n      break;\n    case 'dark':\n      applyDarkVariation(block);\n      break;\n    default:\n      applyDefaultVariation(block);\n  }\n}\n\nfunction applyHighlightVariation(block) {\n  // Add highlight-specific elements\n  const wrapper = document.createElement('div');\n  wrapper.className = 'highlight-wrapper';\n  \n  // Move block children to wrapper\n  while (block.firstChild) {\n    wrapper.appendChild(block.firstChild);\n  }\n  \n  // Add highlight elements\n  const highlightBadge = document.createElement('div');\n  highlightBadge.className = 'highlight-badge';\n  highlightBadge.textContent = 'Featured';\n  \n  // Append elements to block\n  wrapper.prepend(highlightBadge);\n  block.appendChild(wrapper);\n}"
    },
    {
      "id": "h2",
      "title": "Optimizing EDS Performance for Complex Sites",
      "answer": "<p>Optimizing performance for complex AEM Edge Delivery Services sites requires a comprehensive approach that addresses multiple aspects of the delivery pipeline.</p><h3>Performance Optimization Strategies</h3><h4>1. Asset Optimization</h4><ul><li>Implement responsive image delivery with appropriate sizes</li><li>Use modern image formats (WebP, AVIF) with fallbacks</li><li>Implement lazy loading for below-the-fold content</li><li>Optimize SVGs and remove unnecessary metadata</li></ul><h4>2. JavaScript Optimization</h4><ul><li>Implement code splitting to load only necessary code</li><li>Use dynamic imports for non-critical functionality</li><li>Minimize and tree-shake JavaScript dependencies</li><li>Implement proper caching strategies with cache busting</li></ul><h4>3. CSS Optimization</h4><ul><li>Use CSS custom properties for theme consistency</li><li>Implement critical CSS inline loading</li><li>Remove unused CSS with PurgeCSS or similar tools</li><li>Minimize render-blocking CSS</li></ul><h4>4. Edge Optimization</h4><ul><li>Implement edge-side personalization efficiently</li><li>Use edge caching strategies for dynamic content</li><li>Optimize edge worker code for performance</li><li>Implement proper TTL strategies for different content types</li></ul><h4>5. Monitoring and Analysis</h4><ul><li>Implement Real User Monitoring (RUM)</li><li>Set up performance budgets and alerts</li><li>Regularly audit site performance with Lighthouse</li><li>Analyze and optimize Core Web Vitals</li></ul>",
      "code": "// Performance optimization for image loading\nimport { createOptimizedPicture } from '../../scripts/lib-franklin.js';\n\nexport default async function decorate(block) {\n  // Get all images in the block\n  const images = block.querySelectorAll('img');\n  \n  // Process each image for optimization\n  images.forEach((img) => {\n    // Get original image source\n    const src = img.src;\n    \n    // Get image dimensions from dataset or defaults\n    const width = img.dataset.width || 2000;\n    const breakpoints = [375, 768, 1200];\n    \n    // Create optimized picture element\n    const optimizedPicture = createOptimizedPicture(\n      src,\n      img.alt,\n      false,\n      breakpoints,\n    );\n    \n    // Add lazy loading for images below the fold\n    if (!isAboveTheFold(img)) {\n      const newImg = optimizedPicture.querySelector('img');\n      newImg.loading = 'lazy';\n      newImg.decoding = 'async';\n    }\n    \n    // Replace original image with optimized picture\n    img.replaceWith(optimizedPicture);\n  });\n  \n  // Implement intersection observer for content that needs to be loaded on demand\n  const heavyContent = block.querySelectorAll('.heavy-content');\n  if (heavyContent.length > 0) {\n    const observer = new IntersectionObserver((entries) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          loadHeavyContent(entry.target);\n          observer.unobserve(entry.target);\n        }\n      });\n    }, { rootMargin: '200px' });\n    \n    heavyContent.forEach((content) => {\n      observer.observe(content);\n    });\n  }\n}\n\n// Helper function to determine if an element is above the fold\nfunction isAboveTheFold(element) {\n  const rect = element.getBoundingClientRect();\n  return rect.top < window.innerHeight;\n}\n\n// Load heavy content on demand\nasync function loadHeavyContent(container) {\n  const contentId = container.dataset.contentId;\n  try {\n    const response = await fetch(`/api/heavy-content/${contentId}.json`);\n    const data = await response.json();\n    container.innerHTML = data.html;\n    \n    // Initialize any scripts needed for the content\n    const script = document.createElement('script');\n    script.textContent = data.script;\n    container.appendChild(script);\n  } catch (error) {\n    console.error('Error loading heavy content:', error);\n    container.innerHTML = 'Content could not be loaded';\n  }\n}"
    },
    {
      "id": "h3",
      "title": "Integrating EDS with External Systems and APIs",
      "answer": "<p>Integrating AEM Edge Delivery Services with external systems and APIs requires careful architecture to maintain performance while enabling dynamic functionality.</p><h3>Integration Approaches</h3><h4>1. Build-time Integration</h4><p>Data is fetched during the build process and embedded in the static site:</p><ul><li>Pros: Fast page loads, no client-side API calls</li><li>Cons: Content can become stale, requires rebuild for updates</li><li>Best for: Reference data, product catalogs, relatively static content</li></ul><h4>2. Edge-time Integration</h4><p>Data is fetched by EdgeWorkers as requests come in:</p><ul><li>Pros: Fresh data without client-side calls, personalization</li><li>Cons: Potential impact on TTFB, complexity in edge code</li><li>Best for: Personalized content, location-based content, pricing</li></ul><h4>3. Client-side Integration</h4><p>Data is fetched by the browser after page load:</p><ul><li>Pros: Always fresh data, reduced server load</li><li>Cons: Potential CLS issues, additional client-side code</li><li>Best for: User-specific data, real-time updates, interactive features</li></ul><h3>Implementation Strategies</h3><ol><li><strong>API Proxying</strong>: Use EdgeWorkers to proxy API calls to avoid CORS issues and add caching</li><li><strong>Data Caching</strong>: Implement multi-level caching (build, edge, browser)</li><li><strong>Authentication</strong>: Handle tokens securely using edge functions or secure client-side storage</li><li><strong>Error Handling</strong>: Implement graceful fallbacks when APIs are unavailable</li><li><strong>Rate Limiting</strong>: Protect external APIs from excessive calls</li></ol>",
      "code": "// Edge Worker for API integration with caching\nimport { fetch } from 'edge:fetch';\nimport { KVStore } from 'edge:kv-store';\n\n// Initialize KV store for caching\nconst apiCache = new KVStore('api-cache');\n\nexport async function onClientRequest(request) {\n  // Check if this is an API proxy request\n  if (request.path.startsWith('/api-proxy/')) {\n    // Extract the actual API endpoint from the path\n    const apiPath = request.path.replace('/api-proxy/', '');\n    const apiUrl = `https://external-api.example.com/${apiPath}`;\n    \n    // Generate cache key based on URL and any relevant headers\n    const cacheKey = generateCacheKey(request, apiUrl);\n    \n    try {\n      // Try to get from cache first\n      const cachedResponse = await apiCache.get(cacheKey);\n      \n      if (cachedResponse) {\n        // Return cached response if available\n        return new Response(cachedResponse.body, {\n          status: 200,\n          headers: {\n            'Content-Type': 'application/json',\n            'X-Cache': 'HIT',\n            'Cache-Control': 'max-age=60'\n          }\n        });\n      }\n      \n      // Cache miss, fetch from API\n      const apiResponse = await fetch(apiUrl, {\n        headers: {\n          'Authorization': `Bearer ${process.env.API_KEY}`,\n          'Accept': 'application/json'\n        }\n      });\n      \n      if (!apiResponse.ok) {\n        throw new Error(`API responded with status ${apiResponse.status}`);\n      }\n      \n      const responseData = await apiResponse.json();\n      \n      // Cache the response (with appropriate TTL based on content type)\n      const ttl = determineTtl(apiPath, responseData);\n      await apiCache.put(cacheKey, responseData, { ttl });\n      \n      // Return the response to the client\n      return new Response(JSON.stringify(responseData), {\n        status: 200,\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Cache': 'MISS',\n          'Cache-Control': `max-age=${ttl}`\n        }\n      });\n    } catch (error) {\n      // Handle errors gracefully\n      console.error(`API proxy error: ${error.message}`);\n      \n      // Try to return stale cache if available\n      const staleCache = await apiCache.get(cacheKey, { allowStale: true });\n      if (staleCache) {\n        return new Response(staleCache.body, {\n          status: 200,\n          headers: {\n            'Content-Type': 'application/json',\n            'X-Cache': 'STALE',\n            'Cache-Control': 'max-age=30'\n          }\n        });\n      }\n      \n      // If all else fails, return error\n      return new Response(JSON.stringify({ error: 'Service temporarily unavailable' }), {\n        status: 503,\n        headers: {\n          'Content-Type': 'application/json',\n          'Retry-After': '30'\n        }\n      });\n    }\n  }\n  \n  // Not an API proxy request, continue normal processing\n  return request;\n}\n\n// Helper function to generate cache key\nfunction generateCacheKey(request, apiUrl) {\n  // Include relevant request parameters in cache key\n  const userCountry = request.userLocation?.country || 'unknown';\n  const queryParams = new URL(request.url).searchParams.toString();\n  \n  return `${apiUrl}|${queryParams}|${userCountry}`;\n}\n\n// Determine appropriate TTL based on content type\nfunction determineTtl(apiPath, data) {\n  // Product data: cache for 1 hour\n  if (apiPath.includes('/products')) {\n    return 3600;\n  }\n  \n  // User recommendations: cache for 5 minutes\n  if (apiPath.includes('/recommendations')) {\n    return 300;\n  }\n  \n  // Weather data: cache for 30 minutes\n  if (apiPath.includes('/weather')) {\n    return 1800;\n  }\n  \n  // Default: cache for 10 minutes\n  return 600;\n}"
    }
  ]
}
